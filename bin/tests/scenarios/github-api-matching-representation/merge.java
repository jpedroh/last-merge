  package   org . kohsuke . github ;   import static       com . fasterxml . jackson . annotation . JsonAutoDetect . Visibility . ANY ;  import static       com . fasterxml . jackson . annotation . JsonAutoDetect . Visibility . NONE ;  import   java . io . File ;  import   java . io . FileInputStream ;  import   java . io . FileNotFoundException ;  import   java . io . IOException ;  import   java . io . Reader ;  import   java . net . MalformedURLException ;  import   java . net . URL ;  import   java . text . ParseException ;  import   java . text . SimpleDateFormat ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Date ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Properties ;  import   java . util . Set ;  import   java . util . TimeZone ;  import      org . apache . commons . codec . binary . Base64 ;  import     org . apache . commons . io . IOUtils ;  import     com . fasterxml . jackson . databind . DeserializationFeature ;  import     com . fasterxml . jackson . databind . ObjectMapper ;  import       com . fasterxml . jackson . databind . introspect . VisibilityChecker . Std ;  import     com . infradna . tool . bridge_method_injector . WithBridgeMethods ;   public class GitHub  {   final String  login ;   final String  encodedAuthorization ;   private final  Map  < String , GHUser >  users =  new  HashMap  < String , GHUser >  ( ) ;   private final  Map  < String , GHOrganization >  orgs =  new  HashMap  < String , GHOrganization >  ( ) ;   private final String  apiUrl ;   private HttpConnector  connector =  HttpConnector . DEFAULT ;   private GitHub  (  String login ,  String oauthAccessToken ,  String password )  throws IOException  {  this  ( GITHUB_URL , login , oauthAccessToken , password ) ; }   private GitHub  (  String apiUrl ,  String login ,  String oauthAccessToken ,  String password )  throws IOException  {  if  (  apiUrl . endsWith  ( "/" ) )   apiUrl =  apiUrl . substring  ( 0 ,   apiUrl . length  ( ) - 1 ) ;    this . apiUrl = apiUrl ;  if  (  oauthAccessToken != null )  {   encodedAuthorization =  "token " + oauthAccessToken ; } else  {  if  (  password != null )  {  String  authorization =  (   login + ':' + password ) ;   encodedAuthorization =  "Basic " +  new String  (  Base64 . encodeBase64  (  authorization . getBytes  ( ) ) ) ; } else  {   encodedAuthorization = null ; } }  if  (   login == null &&  encodedAuthorization != null )   login =   getMyself  ( ) . getLogin  ( ) ;    this . login = login ; }   public static GitHub connect  ( )  throws IOException  {  Properties  props =  new Properties  ( ) ;  File  homeDir =  new File  (  System . getProperty  ( "user.home" ) ) ;  FileInputStream  in =  new FileInputStream  (  new File  ( homeDir , ".github" ) ) ;  try  {   props . load  ( in ) ; }  finally  {   IOUtils . closeQuietly  ( in ) ; }  return  new GitHub  ( GITHUB_URL ,  props . getProperty  ( "login" ) ,  props . getProperty  ( "oauth" ) ,  props . getProperty  ( "password" ) ) ; }   public static GitHub connectToEnterprise  (  String apiUrl ,  String oauthAccessToken )  throws IOException  {  return  connectUsingOAuth  ( apiUrl , oauthAccessToken ) ; }   public static GitHub connectToEnterprise  (  String apiUrl ,  String login ,  String password )  throws IOException  {  return  new GitHub  ( apiUrl , login , null , password ) ; }   public static GitHub connect  (  String login ,  String oauthAccessToken )  throws IOException  {  return  new GitHub  ( login , oauthAccessToken , null ) ; }   public static GitHub connect  (  String login ,  String oauthAccessToken ,  String password )  throws IOException  {  return  new GitHub  ( login , oauthAccessToken , password ) ; }   public static GitHub connectUsingPassword  (  String login ,  String password )  throws IOException  {  return  new GitHub  ( login , null , password ) ; }   public static GitHub connectUsingOAuth  (  String oauthAccessToken )  throws IOException  {  return  new GitHub  ( null , oauthAccessToken , null ) ; }   public static GitHub connectUsingOAuth  (  String githubServer ,  String oauthAccessToken )  throws IOException  {  return  new GitHub  ( githubServer , null , oauthAccessToken , null ) ; }   public static GitHub connectAnonymously  ( )  throws IOException  {  return  new GitHub  ( null , null , null ) ; }   public boolean isAnonymous  ( )  {  return   login == null &&  encodedAuthorization == null ; }   public HttpConnector getConnector  ( )  {  return connector ; }   public void setConnector  (  HttpConnector connector )  {    this . connector = connector ; }  void requireCredential  ( )  {  if  (  isAnonymous  ( ) )  throw  new IllegalStateException  ( "This operation requires a credential but none is given to the GitHub constructor" ) ; }  URL getApiURL  (  String tailApiUrl )  throws IOException  {  if  (  tailApiUrl . startsWith  ( "/" ) )  {  if  (  "github.com" . equals  ( apiUrl ) )  {  return  new URL  (  GITHUB_URL + tailApiUrl ) ; } else  {  return  new URL  (  apiUrl + tailApiUrl ) ; } } else  {  return  new URL  ( tailApiUrl ) ; } }  Requester retrieve  ( )  {  return   new Requester  ( this ) . method  ( "GET" ) ; }   public GHRateLimit getRateLimit  ( )  throws IOException  {  try  {  return    retrieve  ( ) . to  ( "/rate_limit" ,  JsonRateLimit . class ) . rate ; }  catch (   FileNotFoundException e )  {  GHRateLimit  r =  new GHRateLimit  ( ) ;    r . limit =   r . remaining = 1000000 ;  return r ; } }    @ WithBridgeMethods  (  GHUser . class ) public GHMyself getMyself  ( )  throws IOException  {   requireCredential  ( ) ;  GHMyself  u =   retrieve  ( ) . to  ( "/user" ,  GHMyself . class ) ;    u . root = this ;   users . put  (  u . getLogin  ( ) , u ) ;  return u ; }   public GHUser getUser  (  String login )  throws IOException  {  GHUser  u =  users . get  ( login ) ;  if  (  u == null )  {   u =   retrieve  ( ) . to  (  "/users/" + login ,  GHUser . class ) ;    u . root = this ;   users . put  (  u . getLogin  ( ) , u ) ; }  return u ; }   protected GHUser getUser  (  GHUser orig )  throws IOException  {  GHUser  u =  users . get  (  orig . getLogin  ( ) ) ;  if  (  u == null )  {    orig . root = this ;   users . put  ( login , orig ) ;  return orig ; }  return u ; }   public GHOrganization getOrganization  (  String name )  throws IOException  {  GHOrganization  o =  orgs . get  ( name ) ;  if  (  o == null )  {   o =    retrieve  ( ) . to  (  "/orgs/" + name ,  GHOrganization . class ) . wrapUp  ( this ) ;   orgs . put  ( name , o ) ; }  return o ; }   public GHRepository getRepository  (  String name )  throws IOException  {   String  [ ]  tokens =  name . split  ( "/" ) ;  return    retrieve  ( ) . to  (    "/repos/" +  tokens [ 0 ] + '/' +  tokens [ 1 ] ,  GHRepository . class ) . wrap  ( this ) ; }   public  Map  < String , GHOrganization > getMyOrganizations  ( )  throws IOException  {   GHOrganization  [ ]  orgs =   retrieve  ( ) . to  ( "/user/orgs" ,   GHOrganization  [ ] . class ) ;   Map  < String , GHOrganization >  r =  new  HashMap  < String , GHOrganization >  ( ) ;  for ( GHOrganization o : orgs )  {   r . put  (  o . getLogin  ( ) ,  o . wrapUp  ( this ) ) ; }  return r ; }   public  Map  < String ,  Set  < GHTeam > > getMyTeams  ( )  throws IOException  {   Map  < String ,  Set  < GHTeam > >  allMyTeams =  new  HashMap  < String ,  Set  < GHTeam > >  ( ) ;  for ( GHTeam team :   retrieve  ( ) . to  ( "/user/teams" ,   GHTeam  [ ] . class ) )  {   team . wrapUp  ( this ) ;  String  orgLogin =   team . getOrganization  ( ) . getLogin  ( ) ;   Set  < GHTeam >  teamsPerOrg =  allMyTeams . get  ( orgLogin ) ;  if  (  teamsPerOrg == null )  {   teamsPerOrg =  new  HashSet  < GHTeam >  ( ) ; }   teamsPerOrg . add  ( team ) ;   allMyTeams . put  ( orgLogin , teamsPerOrg ) ; }  return allMyTeams ; }   public  List  < GHEventInfo > getEvents  ( )  throws IOException  {   GHEventInfo  [ ]  events =   retrieve  ( ) . to  ( "/events" ,   GHEventInfo  [ ] . class ) ;  for ( GHEventInfo e : events )   e . wrapUp  ( this ) ;  return  Arrays . asList  ( events ) ; }   public GHGist getGist  (  String id )  throws IOException  {  return    retrieve  ( ) . to  (  "/gists/" + id ,  GHGist . class ) . wrapUp  ( this ) ; }   public GHGistBuilder createGist  ( )  {  return  new GHGistBuilder  ( this ) ; }   public  <  T  extends GHEventPayload > T parseEventPayload  (  Reader r ,   Class  < T > type )  throws IOException  {  T  t =  MAPPER . readValue  ( r , type ) ;   t . wrapUp  ( this ) ;  return t ; }   public GHRepository createRepository  (  String name ,  String description ,  String homepage ,  boolean isPublic )  throws IOException  {  Requester  requester =      new Requester  ( this ) . with  ( "name" , name ) . with  ( "description" , description ) . with  ( "homepage" , homepage ) . with  ( "public" ,  isPublic ? 1 : 0 ) ;  return    requester . method  ( "POST" ) . to  ( "/user/repos" ,  GHRepository . class ) . wrap  ( this ) ; }   public GHAuthorization createToken  (   Collection  < String > scope ,  String note ,  String noteUrl )  throws IOException  {  Requester  requester =     new Requester  ( this ) . with  ( "scopes" , scope ) . with  ( "note" , note ) . with  ( "note_url" , noteUrl ) ;  return    requester . method  ( "POST" ) . to  ( "/authorizations" ,  GHAuthorization . class ) . wrap  ( this ) ; }   public boolean isCredentialValid  ( )  throws IOException  {  try  {    retrieve  ( ) . to  ( "/user" ,  GHUser . class ) ;  return true ; }  catch (   IOException e )  {  return false ; } }   static URL parseURL  (  String s )  {  try  {  return   s == null ? null :  new URL  ( s ) ; }  catch (   MalformedURLException e )  {  throw  new IllegalStateException  (  "Invalid URL: " + s ) ; } }   static Date parseDate  (  String timestamp )  {  if  (  timestamp == null )  return null ;  for ( String f : TIME_FORMATS )  {  try  {  SimpleDateFormat  df =  new SimpleDateFormat  ( f ) ;   df . setTimeZone  (  TimeZone . getTimeZone  ( "GMT" ) ) ;  return  df . parse  ( timestamp ) ; }  catch (   ParseException e )  { } }  throw  new IllegalStateException  (  "Unable to parse the timestamp: " + timestamp ) ; }   static String printDate  (  Date dt )  {  return   new SimpleDateFormat  ( "yyyy-MM-dd'T'HH:mm:ss'Z'" ) . format  ( dt ) ; }   static final ObjectMapper  MAPPER =  new ObjectMapper  ( ) ;   private static final  String  [ ]  TIME_FORMATS =  { "yyyy/MM/dd HH:mm:ss ZZZZ" , "yyyy-MM-dd'T'HH:mm:ss'Z'" } ;  static  {   MAPPER . setVisibilityChecker  (  new Std  ( NONE , NONE , NONE , NONE , ANY ) ) ;   MAPPER . configure  (  DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES , false ) ; }   private static final String  GITHUB_URL = "https://api.github.com" ;   public void refreshCache  ( )  {   users . clear  ( ) ;   orgs . clear  ( ) ; } }